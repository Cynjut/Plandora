package com.pandora.bus.artifact;

import java.awt.Color;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URLEncoder;
import java.util.UUID;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.tidy.Tidy;

import com.lowagie.text.Cell;
import com.lowagie.text.Chunk;
import com.lowagie.text.DocumentException;
import com.lowagie.text.Element;
import com.lowagie.text.Font;
import com.lowagie.text.HeaderFooter;
import com.lowagie.text.List;
import com.lowagie.text.PageSize;
import com.lowagie.text.Paragraph;
import com.lowagie.text.Phrase;
import com.lowagie.text.Table;
import com.lowagie.text.pdf.draw.LineSeparator;
import com.lowagie.text.rtf.RtfWriter2;
import com.lowagie.text.rtf.style.RtfFont;
import com.pandora.bus.SystemSingleton;
import com.pandora.helper.HtmlUtil;
import com.pandora.helper.XmlDomParse;


public class RTFArtifactExport extends ArtifactExport {

	private final static int        FLAT_STYLE = 0;
		
	private final static int FLAT_STYLE_STRIKE = 2;
	
	private final static int FLAT_STYLE_STRONG = 3;
	
	private final static int FLAT_STYLE_ITALIC = 4;
	
	private final static int          H1_STYLE = 10;
	
	private final static int          H2_STYLE = 11;

	private final static int          H3_STYLE = 12;
	
	private final static int          H4_STYLE = 13;
	
	private final static int          H5_STYLE = 14;
	
	private final static int          H6_STYLE = 15;
	
	private final static float       PAGE_SIZE = 1025f;
	
	
	@Override
	public byte[] export(String header, String body, String footer) throws Exception {
		byte[] response = null;
		ByteArrayInputStream bis = null;
		com.lowagie.text.Document doc = null;
		
		try {
			bis = new ByteArrayInputStream(body.getBytes());
			Tidy tidy = new Tidy();             
			Document docHtml = tidy.parseDOM(bis, null);						
			XmlDomParse.write(docHtml, "teste.xml");
			
			NodeList list = docHtml.getElementsByTagName("body");
			if (list!=null) {
				
				String rtfTempName = UUID.randomUUID().toString() + ".rtf";
				
				Node bodyNode = list.item(0);
				doc = new com.lowagie.text.Document(PageSize.A4, 50, 50, 50, 50);
				doc.addSubject("This document was generated by Plandora tool."); 
				
				RtfWriter2.getInstance(doc, new FileOutputStream(rtfTempName));
			    doc.open();
				this.format(doc, bodyNode);
								
				HeaderFooter h = new HeaderFooter(new Phrase("This is a header."), false);
				HeaderFooter f = new HeaderFooter(new Phrase("This is page "), new Phrase("."));
				f.setAlignment(Element.ALIGN_CENTER);
				doc.setHeader(h); 
				doc.setFooter(f);
				
				File destination = new File(rtfTempName);
				System.out.println(destination.length());
				response = this.read(destination);
			}
			
		} catch(Exception e){
			e.printStackTrace();
		} finally{
			if (bis!=null) {
				bis.close();
			}
			if (doc!=null) {
				doc.close();
			}
		}
		return response;	
	}

	
	@Override
	public String getContentType() {
		return "text/richtext";
	}
	

	@Override
	public String getExtension() {
		return ".rtf";
	}
	

	@Override
	public String getUniqueName() {
		return "label.artifactTag.export.rtf";
	}
		

	public byte[] read(File file) throws Exception {
	    byte[] buffer = new byte[(int) file.length()];
	    InputStream ios = null;
	    try {
	        ios = new FileInputStream(file);
	        if ( ios.read(buffer) == -1 ) {
	            throw new IOException("EOF reached while trying to read the whole file");
	        }        
	    } finally { 
	        try {
	             if (ios!=null) {
	                  ios.close();
	             }
	        } catch (IOException e) {
	        	e.printStackTrace();
	        }
	    }

	    return buffer;
	}	
	
	private void format(com.lowagie.text.Document doc, Node node) throws Exception{
		boolean childParsing = true;
		
		if (node.getNodeName().equalsIgnoreCase("p")){
			Phrase phrase = formatText(node, FLAT_STYLE);
    		if (phrase!=null) {
    			doc.add(phrase);	
    		}
    		this.newLine(doc, getFont(FLAT_STYLE));
		} else if (node.getNodeName().equalsIgnoreCase("em")){
			Phrase phrase = formatText(node, FLAT_STYLE);
    		if (phrase!=null) {
    			doc.add(phrase);	
    		}
    		this.newLine(doc, getFont(FLAT_STYLE));
            
		} else	if (node.getNodeName().equalsIgnoreCase("h6")){			
			Phrase phrase = formatText(node, H6_STYLE);
    		if (phrase!=null) {
    			doc.add(phrase);	
    		}
    		this.newLine(doc, getFont(H6_STYLE));

		} else	if (node.getNodeName().equalsIgnoreCase("h5")){			
			Phrase phrase = formatText(node, H5_STYLE);
    		if (phrase!=null) {
    			doc.add(phrase);	
    		}
    		this.newLine(doc, getFont(H5_STYLE));

		} else	if (node.getNodeName().equalsIgnoreCase("h4")){			
			Phrase phrase = formatText(node, H4_STYLE);
    		if (phrase!=null) {
    			doc.add(phrase);	
    		}
    		this.newLine(doc, getFont(H4_STYLE));

		} else	if (node.getNodeName().equalsIgnoreCase("h3")){			
			Phrase phrase = formatText(node, H3_STYLE);
    		if (phrase!=null) {
    			doc.add(phrase);	
    		}
    		this.newLine(doc, getFont(H3_STYLE));
    		
		} else	if (node.getNodeName().equalsIgnoreCase("h2")){			
			Phrase phrase = formatText(node, H2_STYLE);
    		if (phrase!=null) {
    			doc.add(phrase);	
    		}
    		this.newLine(doc, getFont(H2_STYLE));

		} else	if (node.getNodeName().equalsIgnoreCase("h1")){			
			Phrase phrase = formatText(node, H1_STYLE);
    		if (phrase!=null) {
    			doc.add(phrase);	
    		}
    		this.newLine(doc, getFont(H1_STYLE));
    		
		} else	if (node.getNodeName().equalsIgnoreCase("ul")){
			Phrase listphrase = new Phrase();
			formatList(listphrase, node, false, 0);
    		if (listphrase!=null) {
    			doc.add(listphrase);	
    		}
			childParsing = false;
			
		} else	if (node.getNodeName().equalsIgnoreCase("ol")){
			Phrase listphrase = new Phrase();
			formatList(listphrase, node, true, 0);
    		if (listphrase!=null) {
    			doc.add(listphrase);	
    		}			
			childParsing = false;
			
		} else	if (node.getNodeName().equalsIgnoreCase("table")){
			formatTable(doc, node);
			childParsing = false;
			
		} else	if (node.getNodeName().equalsIgnoreCase("hr")){
			LineSeparator ls = new LineSeparator();
			doc.add(ls);
			childParsing = false;			
		}
		
		if (childParsing) {
			NodeList nodes = node.getChildNodes();
			for (int i =0 ; i<nodes.getLength(); i++) {
				Node child = nodes.item(i);
				format(doc, child);
			}			
		}
	}
	
	
	private void formatTable(com.lowagie.text.Document doc, Node node) throws DocumentException, MalformedURLException, IOException {
		Node tbodyNode = node.getFirstChild();
		if (tbodyNode!=null) {
			
			int maxCols = this.countCols(tbodyNode);			
			Table t = new Table(maxCols);
			this.setupTable(t, node);

			NodeList nodes = tbodyNode.getChildNodes();
			for (int i =0 ; i<nodes.getLength(); i++) {
				Node n = nodes.item(i);
				if (n.getNodeName().equalsIgnoreCase("tr")) {					
					NodeList nodeCols = n.getChildNodes();
					for (int j =0 ; j<nodeCols.getLength(); j++) {
						Node ntd = nodeCols.item(j);
						if (ntd.getNodeName().equalsIgnoreCase("td")) {
														
							Phrase contentCell = this.formatText(ntd, FLAT_STYLE);
							Cell cell = new Cell(contentCell);							
							this.setupCell(cell, ntd);
							
							//cell.setRowspan(2);
							//cell.setColspan(2);
							t.addCell(cell);
						}
					}
				}
			}

			doc.add(t);
		}
	}


	private Phrase formatText(Node node, int styleType) throws DocumentException, MalformedURLException, IOException {
		NodeList nodes = node.getChildNodes();
		Phrase response = null;
		
		for (int i =0 ; i<nodes.getLength(); i++) {
			Node n = nodes.item(i);
			RtfFont font = this.getFont(styleType);
			
			if (response==null) {
				response = new Phrase();
			}

			if (n.getNodeName().equalsIgnoreCase("span")) {

				String c2 = getText(n);
				if (c2!=null) {
					Chunk container = new Chunk();

					String fontName = getStyle(n, "font-family");
					if (fontName!=null && !fontName.trim().equals("")) {
						String[] fonts = fontName.split(",");
						if (fonts!=null) {
							font.setFamily(fonts[0].trim());
						}
					}
					
					String fontColor = getStyle(n, "color");
					if (fontColor!=null) {
						font.setColor(HtmlUtil.decodeColor(fontColor));	
					}
					
					String bgColor = getStyle(n, "background-color");
					if (bgColor!=null) {
						container.setBackground(HtmlUtil.decodeColor(bgColor));	
					}
					
					String fontSize = getStyle(n, "font-size");
					if (fontSize!=null) {
						if (fontSize.equals("xx-small")) {
							font.setSize(8);
						} else if (fontSize.equals("x-small")) {
							font.setSize(10);
						} else if (fontSize.equals("small")) {
							font.setSize(12);
						} else if (fontSize.equals("medium")) {
							font.setSize(14);
						} else if (fontSize.equals("large")) {
							font.setSize(18);
						} else if (fontSize.equals("x-large")) {
							font.setSize(24);
						} else if (fontSize.equals("xx-large")) {
							font.setSize(36);
						}
					}

					String classStyle = XmlDomParse.getAttributeTextByTag(n, "class");
					if (classStyle!=null && !classStyle.trim().equals("")){
						if (classStyle.equalsIgnoreCase("underline")) {
							font.setStyle(Font.UNDERLINE);
						} else if (classStyle.equalsIgnoreCase("bold")) {
							font.setStyle(Font.BOLD);
						} else if (classStyle.equalsIgnoreCase("italic")) {
							font.setStyle(Font.ITALIC);
						}
					}

					container.setFont(font);					
					container.append(c2);
					response.add(container);
				}
				
				//TODO se span tiver sub-tags (como por exemplo img) precisa adiciona-las tmb.  mas talvez não possa chamar formatText recorrente porque irá duplicar os conteúdos de <p> 
							
			} else if (n.getNodeName().equalsIgnoreCase("p")) {
				response.add(this.formatText(n, FLAT_STYLE));

			} else if (n.getNodeName().equalsIgnoreCase("img")) {
				String srcAtt = XmlDomParse.getAttributeTextByTag(n, "src");
				com.lowagie.text.Image image = com.lowagie.text.Image.getInstance(srcAtt);
				//response.add(image); //não consigo inserir image em um objeto Phase 
				
			} else if (n.getNodeName().equalsIgnoreCase("strong")) {
				response.add(this.formatText(n, FLAT_STYLE_STRONG));

			} else if (n.getNodeName().equalsIgnoreCase("del")) {
				response.add(this.formatText(n, FLAT_STYLE_STRIKE));

			} else if (n.getNodeName().equalsIgnoreCase("ul")){
				formatList(response, n, false, 0);
				
			} else	if (n.getNodeName().equalsIgnoreCase("ol")){
				formatList(response, n, true, 0);
				
			} else if (n.getNodeType()==3) {
				String content = n.getNodeValue();
				String encoding = SystemSingleton.getInstance().getDefaultEncoding();				
				if (content!=null && !URLEncoder.encode(content, encoding).equals("%C2%A0") ) {
					Chunk container = new Chunk();
					container.setFont(font);
					
					String classStyle = XmlDomParse.getAttributeTextByTag(node, "class");
					if (classStyle!=null && !classStyle.trim().equals("")){
						if (classStyle.equalsIgnoreCase("center")) {

						}
					}
					
					container.append(content);
					response.add(container);
				}
			}			
		}
		
		return response;
	}


	private void newLine(com.lowagie.text.Document doc, Font font)
			throws DocumentException {
		Paragraph newline = new Paragraph();
		newline.setFont(font);
		doc.add(newline);
	}
	
	
	private void formatList(com.lowagie.text.Phrase phraseList, Node node, boolean isOrdered, int level) 
		throws DocumentException, MalformedURLException, IOException {
		List list = null;
		level = level + 1;

		NodeList nodes = node.getChildNodes();
		if (nodes!=null && nodes.getLength()>0) {
			list = new List();	
		}
				
		for (int i=0 ; i<nodes.getLength(); i++) {
			Node n = nodes.item(i);
			if (n.getNodeName().equalsIgnoreCase("li")) {
				
				String content = this.getText(n);
				Phrase sub = this.formatText(n, FLAT_STYLE);
				
				String bulletType = this.getStyle(node, "list-style-type");
				if (bulletType!=null) {
					list.setLettered(true);
					list.setLowercase(bulletType.indexOf("lower")>-1);
					list.setNumbered(false);
				} else {
					list.setLettered(false);
					list.setNumbered(isOrdered);
					//list.setSymbolIndent(level);
					//list.setListSymbol(new Chunk("\u00b7", new Font(Font.COURIER, 13, Font.NORMAL, 
					//		new Color(0, 0, 0))));
				}
				
				list.setIndentationLeft(20f * level);
				if (sub!=null && sub.getContent()!=null && !sub.getContent().equals("")) {
					list.add(sub);
				} else {
					list.add(content);	
				}
			}
		}
		
		if (list!=null) {
			phraseList.add(list);
		}
		
		for (int i=0 ; i<nodes.getLength(); i++) {
			Node n = nodes.item(i);
			if (n.getNodeName().equalsIgnoreCase("li")) {
				NodeList liNodes = n.getChildNodes();
				for (int j=0 ; j<liNodes.getLength(); j++) {
					Node liChild = liNodes.item(j);
					if (liChild.getNodeName().equalsIgnoreCase("ul")) {
						formatList(phraseList, liChild, false, level);
					} else if (liChild.getNodeName().equalsIgnoreCase("ol")) {
						formatList(phraseList, liChild, true, level);
					}				
				}
			}
		}
	}

	
	private String getText(Node node) throws UnsupportedEncodingException {
		String response = null;
		
		NodeList nodes = node.getChildNodes();
		for (int i =0 ; i<nodes.getLength(); i++) {
			Node c = nodes.item(i);
			if (c.getNodeType()==3) {
				String content = c.getNodeValue();
				String encoding = SystemSingleton.getInstance().getDefaultEncoding();				
				if (content!=null && !URLEncoder.encode(content, encoding).equals("%C2%A0") ) {
					response = content;
				}
			}			
		}
		return response;
	}	
	
	private String getStyle(Node n, String styleId){
		String response = null;
		
		String style = XmlDomParse.getAttributeTextByTag(n, "style");
		if (style!=null && !style.trim().equals("")) {
			String[] styles = style.split(";");
			if (styles!=null) {
				for (int s=0; s<styles.length; s++) {
					String theStyle = styles[s];
					if (theStyle!=null && !theStyle.trim().equals("")) {
						String[] tokens = theStyle.trim().split(":");
						if (tokens!=null && tokens.length==2) {
							if (tokens[0].trim().equals(styleId)) {
								response = tokens[1].trim();
							}
						}
					}
				}
			}
		}
		
		return response;
	}
	
	private RtfFont getFont(int styleType) {
		RtfFont response = new RtfFont("Verdana", 10, Font.NORMAL);
		response.setColor(Color.BLACK);
		if (styleType==H6_STYLE) {
			response.setSize(6);
			response.setStyle(Font.BOLD);

		} else if (styleType==H5_STYLE) {
			response.setSize(7);
			response.setStyle(Font.BOLD);

		} else if (styleType==H4_STYLE) {
			response.setSize(8);
			response.setStyle(Font.BOLD);
			
		} else if (styleType==H3_STYLE) {
			response.setSize(10);
			response.setStyle(Font.BOLD);
			
		} else if (styleType==H2_STYLE) {
			response.setSize(13);
			response.setStyle(Font.BOLD);

		} else if (styleType==H1_STYLE) {
			response.setSize(18);
			response.setStyle(Font.BOLD);
			
		} else if (styleType==FLAT_STYLE_STRIKE) {
			response.setSize(8);
			response.setStyle(Font.STRIKETHRU);
			
		} else if (styleType==FLAT_STYLE_STRONG) {
			response.setSize(8);
			response.setStyle(Font.BOLD);

		} else if (styleType==FLAT_STYLE_ITALIC) {
			response.setSize(8);
			response.setStyle(Font.ITALIC);
			
		} else if (styleType==FLAT_STYLE) {
			response.setSize(8);
		}
		return response;
	}
	
	private int countCols(Node tbodyNode){
		int maxCols = 0;
		NodeList nodes = tbodyNode.getChildNodes();
		for (int i =0 ; i<nodes.getLength(); i++) {
			Node n = nodes.item(i);
			if (n.getNodeName().equalsIgnoreCase("tr")) {
				int cols = 0;					
				NodeList nodeCols = n.getChildNodes();
				for (int j =0 ; j<nodeCols.getLength(); j++) {
					Node ntd = nodeCols.item(i);
					if (ntd!=null && ntd.getNodeName()!=null && ntd.getNodeName().equalsIgnoreCase("td")) {
						cols++;
						if (maxCols<=cols) {
							maxCols = cols;
						}
					}
				}
			}
		}		
		return maxCols;
	}
	
	
	private void setupCell(Cell cell, Node ntd) {

		String valign = XmlDomParse.getAttributeTextByTag(ntd, "valign", false);
		if (valign!=null && !valign.trim().equals("")) {								
			if (valign.equals("top")) {
				cell.setVerticalAlignment(Cell.ALIGN_TOP);
			} else if (valign.equals("botton")) {
				cell.setVerticalAlignment(Cell.ALIGN_BOTTOM);
			}
		}

		
		String width = XmlDomParse.getAttributeTextByTag(ntd, "width", false);
		if (width!=null && !width.trim().equals("")) {
			cell.setWidth(getPercentual(width));	
		}

		String classStyle = XmlDomParse.getAttributeTextByTag(ntd, "class");

		//verify if there is a <p> into the cell and extract the class property from <p>
		Node pNode = ntd.getFirstChild();
		if (pNode.getNodeName().equalsIgnoreCase("p")) {
			classStyle = XmlDomParse.getAttributeTextByTag(pNode, "class");
		}

		if (classStyle!=null && !classStyle.trim().equals("")){
			if (classStyle.equalsIgnoreCase("center")) {
				cell.setHorizontalAlignment(Cell.ALIGN_CENTER);
			} else if (classStyle.equalsIgnoreCase("right")) {
				cell.setHorizontalAlignment(Cell.ALIGN_RIGHT);
			} else if (classStyle.equalsIgnoreCase("left")) {
				cell.setHorizontalAlignment(Cell.ALIGN_LEFT);
			}
		}			
		
		
	}


	private void setupTable(Table t, Node node) {
		t.setAlignment(Table.ALIGN_LEFT);
		t.setBorderColor(new Color(220, 255, 100));
		
		String width = XmlDomParse.getAttributeTextByTag(node, "width", false);
		String cellpadding = XmlDomParse.getAttributeTextByTag(node, "cellpadding", false);
		String cellspacing = XmlDomParse.getAttributeTextByTag(node, "cellspacing", false);
		String border = XmlDomParse.getAttributeTextByTag(node, "border", false);

		if (width!=null && !width.trim().equals("")) {
			t.setWidth(getPercentual(width));	
		} else {
			t.setWidth(100);
		}
		if (cellpadding!=null && !cellpadding.trim().equals("")) {
			t.setPadding(Integer.parseInt(cellpadding));	
		}
		if (cellspacing!=null && !cellspacing.trim().equals("")) {
			t.setSpacing(Integer.parseInt(cellspacing));
		}
		if (border!=null && !border.trim().equals("")) {
			t.setBorderWidth(Integer.parseInt(border));
		}
	}
	
	private float getPercentual(String content) {
		float response = 0;
		if (content!=null && !content.trim().equals("")) {
			if (content.endsWith("%")) {
				response = Float.parseFloat(content.replaceAll("%", ""));	
			} else {
				float val = Float.parseFloat(content);
				response = (val / PAGE_SIZE) * 100 ; 
			}
				
		}
		return response;
	}

}
